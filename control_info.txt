

<<Control>> Global [] 00000000 
<prop>
retval <R> I [] 
retstr <R> S [] 
<method> 
AddFocus <> 01 01 
        handle H [] 
        I [] 
ClearScreen <> 01 01 
        flag I [] <> 
        I [] 
CreatePage <> 01 01 
        page_handle H [] 
        I [] 
CreateTimer <B> 07 01 
        target_handle H [] <> //name is act as param0 of message
        name S [] <> //name is act as param0 of message
        delay_time I [0] <> //the unit is 100ms
        MsgStrParam S [] <> //param1 of message
        MsgParam2 I [] <> 
        MsgParam3 I [] <> 
        period_flag I [] <> //0: one time timer
//1: period timer
        I [] 
DeleteTimer <> 01 01 
        name S [] 
        I [] 
DestoryPage <> 01 01 
        page_handle H [] 
        I [] 
GetCntDrawState <> 01 01 
        CntlHandle H [] <> 
        I [] 
GetDefLanguage <> 00 01 
        I [] //return default language ID
GetHdmode <> 00 01 
        I [:HDMODE] 
GetLastShowPage <> 00 01 //to get the handle of latest page showed
        H [] //The latest page showed
GetVolume <> 00 01 //The volume has been divided into 64 grade, from 0, 1, 2, ... to 64, 0 is mute, 64 is MAX
        I [] 
HideControl <> 01 01 
        cntl_handle H [] 
        I [] 
HideOsdSlide <> 04 01 
        page_handle H [] <> //any page in the area you want to hide is ok
        direction I [] <> 
        speed I [] <> 
        fade I [] <> 
        I [] 
HidePage <> 01 01 
        page_handle H [] 
        I [] 
HidePageFade <> 02 01 
        page_handle H [] //handle of the page want to hide
        fade_speed I [0] //0~7 larger the faster
        I [] 
HidePageSlide <> 03 01 
        page H [] <> //page handle
        effect I [] <> //#define FADE_OUT                    9
//#define ZOOM_OUT                    10
//#define ROTATE_OUT                  11
        effect_param I [] <> //speed or step
        I [] 
IsFocused <> 01 01 //1: the handle is focused 0: not focused
        handle H [] <> //handle of page/window/control
        I [] 
IsShown <> 01 01 
        handle H [] <> 
        I [] 
KeepScreen <> 01 01 
        flag I [] <> 
        I [] 
LoadLogo <> 02 01 
        file_handle RT [] <> //Logo resource file
        flag I [] <> //0: normal
//1: smooth jpeg
//2: sync jpeg
//3: mi jpeg
        I [] 
LoadLogoInRect <> 03 01 
        file RT [] <> 
        rect H [Rect] <> 
        flag I [] <N> //reserved
        I [] 
NetfsGetFileNum <> 02 01 //get total file number in the path of netfs
//return -1 or 0  if this count is not available,  in this case, "block calling" of  GeneralFileTree.ReqGetItemNum can be used to get files number.
        path_name S [] <> //the full pathname of directory
        flag I [] <> //reserved
        I [] 
OSDAreaCreate <> 08 01 //create a area in a OSD layer
        layer I [] <> //osd layer
        type I [] <> //osd type:
//#define OSD_TYPE_4BPP   0
//#define OSD_TYPE_8BPP   1
//#define OSD_TYPE_16BPP  2
//#define OSD_TYPE_32BPP  3
        x I [] <> //start x
        y I [] <> //start y
        w I [] <> //width
        h I [] <> //height
        h_show I [] <> //height of show area, normally same as h, except user nee extra osd area for cache
        mode I [] <> //reserved
        I [] 
OSDLayerCreate <> 03 01 //create a osd layer by width and height
        layer I [0] //osd layer to create
        width I [] //osd buffer width
        height I [] //osd buffer height
        I [] 
OSDLayerDestroy <> 01 01 //destroy an existing osd layer
        layer I [0] //osd layer to destroy
        I [] 
OSDLayerHide <> 01 01 
        layer I [] <> 
        I [] 
OSDLayerShow <> 01 01 
        layer I [] <> 
        I [] 
RemoveFocus <> 01 01 
        handle H [] 
        I [] 
ReqTotalFilSize <B> 01 01 //This method can only be "Blocking" called, the return parameter name is: "i_ret" (INT, get by control InOutParam.GetBlkFunRetVal). 
        play_list H [PlayList] <> // 
        I [] 
SetCnInitShowSt <> 02 01 
        cntl_handle H [] 
        init_show_state I [] 
        I [] 
SetCntDrawState <> 02 01 
        CntlHandle H [] 
        DrawState I [] 
        I [] //Set DrawState of some control
//The default DrawState of control is 1.
//Control will not be drawed if it's DrawState is 0.
SetDefaultFont <> 01 01 
        font_group_id I [0] //font_id: 0~ max_supported_font_num-1
        I [] 
SetDefBgColor <> 01 01 
        color I [] 
        I [] 
SetDefFgColor <> 01 01 
        color I [] 
        I [] 
SetDefLanguage <> 01 01 
        language_id I [0] //language id is from 0 to max_supported_language -1 
        I [] 
SetHdmode <> 01 01 
        Hdmode I [:HDMODE] <> 
        I [] 
SetOSDLayerPos <> 05 01 
        layer I [] <> 
        x I [] <> 
        y I [] <> 
        delay I [] <> 
        step I [] <> 
        I [] 
SetOSDPosition <> 05 01 
        layer I [] <> 
        x I [] <> 
        y I [] <> 
        delay I [] <> 
        step I [] <> 
        I [] 
SetOSDRotation <> 01 01 
        degree I [] <> //0,90,180,270
        I [] 
SetOSDTopLayer <> 01 01 //set which osd layer is on top, 
//0: layer 0 on top on layer 1, 
//1: layer 1 on top of layer 0
        layer I [0] //osd layer: 0 or 1
        I [] 
SetVolume <> 01 01 //The volume has been divided into 64 grade, from 0, 1, 2, ... to 64, 0 is mute, 64 is MAX
        volume_level I [] <> 
        I [] 
ShowControl <B> 02 01 
        cntl_handle H [] <> 
        flag I [] <> 
        I [] 
ShowHidePage <> 05 01 //Hide a page and show a page with effect, for slide effect only the show page area will do effect. Make sure the page show area is same or bigger than hide page area.
        show_page H [] <> //page to show 
        hide_page H [] <> //page to hide(only hide it, no destroy)
        focus_flag I [] <> //0: show only
//1: show and add focus
//2: show, add focus and remove other pages focua 
        effect I [] <> //#define NO_EFFECT                   0
//#define SLIDE_RIGHT                 1
//#define SLIDE_LEFT                  2
//#define SLIDE_UP                    3
//#define SLIDE_DOWN                  4
//#define SLIDE_MIDDLE2VSIDE          5
//#define FADE_IN                     6
//#define ZOOM_IN                     7
//#define ROTATE_IN                   8
//#define FADE_OUT                    9
//#define ZOOM_OUT                    10
//#define ROTATE_OUT                  11
//#define FADE_IN_FADE_OUT            12
//#define KEEP_OFFSCR                 0xffff
        effect_param I [] <> //for SLIDE_RIGHT, SLIDE_LEFT, SLIDE_UP, SLIDE_DOWN, ZOOM_IN, ZOOM_OUT -- move/scale pixels each step
//for ROTATE_IN, ROTATE_OUT -- degree(0-360) each step
        I [] 
ShowOsdSlide <> 04 01 
        page_handle H [] <> //the last page handle in the osd area you want to show 
        focus_flag I [] <> //0: show only
//1: show with focus
//2: show with focus and remove all other pages focus
        direction I [] <> //#define SLIDE_RIGHT                 1           
//#define SLIDE_LEFT                  2
//#define SLIDE_UP                    3
//#define SLIDE_DOWN                  4
//#define SLIDE_MIDDLE2VSIDE			5 
//#define NONE_FADE					6
        speed I [] <> //the bigger the faster
        I [] 
ShowPage <B> 02 01 
        page_handle H [] <> 
        focus_flag I [] <> //1 -- add ctrls handing input in this page into focus list;
//0 -- not add ctrls handing input in this page into focus list.
        I [] 
ShowPageFade <B> 03 01 //Show Page with fade in effect, should no other page share palette with it show at the same time.
        page_handle H [] <> //page handle want to show
        focus_flag I [0] <> //0: not add focus 1:add focus 2:add focus and remove other
        fade_speed I [0] <> //0~7 larger the faster
        I [] 
ShowPageSlide <B> 04 01 
        page_handle H [] <> 
        focus_flag I [0] <> //0: show only
//1: show with focus
//2: show with focus and remove all other pages focus
        direction I [] <> //#define SLIDE_RIGHT                 1           
//#define SLIDE_LEFT                  2
//#define SLIDE_UP                    3
//#define SLIDE_DOWN                  4
//#define SLIDE_MIDDLE2VSIDE          5
//#define FADE_IN                     6
//#define ZOOM_IN                     7
//#define ROTATE_IN                   8
        speed I [] <> //step or speed
        I [] 
UITaskChangPrio <> 01 01 //Change the priority of UITask, whose default priority is 17.
//To improve the performance of music, user can  change priority of UITask to 20 when it is playing music.
        new_priority I [] <> //
//        I [] 
        I [] 
<event>
AFMSG_SYS_REGISTER <>
AFMSG_SYS_DRAW <>
AFMSG_SYS_HIDE <>
AFMSG_SYS_INIT <>
AFMSG_SYS_PAGE_DESTROYED <>
AFMSG_SYS_TIMER <>
AFMSG_SYS_LOST_FOCUS <>
AFMSG_SYS_GOT_FOCUS <>
AFMSG_SYS_DRIVER_REGISTER <>



<<Control>> BlockDevFormat [] 00000002 <> 
<prop>
<method>
Format <> 05 01 //Before format device, user need call BlockDevMonitor->Unmount to unmount this device.
//How to format device:
//Blocking call BlockDevMonitor->Unmount(dev_name);
//BlockDevMonitor->Stop()
//BlockDevFormat->Format(dev_name);
//BlockDevMonitor->Start();
        dev_name S [] <> 
        label S [] <N> 
        fs_type I [:FsType] <N> 
        fs_subtype I [] <N> //If fs_type is FAT, fs_subtype==0: FAT16; fs_subtype==1: FAT32
        config I [] <N> //config[0]:  1, do not format device if this device has been formated
        I [] 
GetDeviceInfo <> 02 01 //Get device information: free space, size ,etc
//not implemented still
        dev_name S [] <> 
        flag I [] <> 
        I [] 
<event>



<<Control>> BlockDevMonitor [] 00000020 <S> 
<prop>
MntPointConfig <S> I [0~1] //0, mount points have format: /mnt/TypeStr/dev_name; 1, mount points have format: /mnt/dev_name
AutoMountConfig <S> I [] //bit[3~0]
//0, auto detection of partitions and auto mount; 
//bit[7~4]
//0, "unmount all"  and send message of AFMSG_DEVST_PC_CONNECT when "pc connect"
//1, only send message of AFMSG_DEVST_PC_CONNECT when "pc connect"
//bit[8]: 1, do not mount resource device automatically; 0, mount resource device automatically. 
DeviceInfo <S> H [StringTableWR] //if this prop is not NULL, the information of all mounted devices will be put into this table:
//The name of each row is mount_point
//the information put into cols are same as parameters of POST_MOUNT.
//the nickname of each col is:
//"dev_name":  /dev/disk/nanda0, etc
//"dev_type_str": UDISK, NAND, CF, SD, SD2, MMC, XD, MS, UPNP, PIC_GALLERY, etc
//"mount_point"
//"label"
//"fs_type": FS_UNKNOWN, FAT_FS, NETFS_FS, etc
//"fs_option": READ_ONLY, READ_WRITE
DiskFreeSpace <R> I [] //the return information of GetDiskInfo.
DiskSectorNum <R> I [] //the return information of GetDiskInfo.
DiskSectorSize <R> I [] //the return information of GetDiskInfo.
MountRules <S> AS [0~;] //The mount rule, format is "device_name:", sample: "/dev/disk/nanda1", do not mount '/dev/disk/nanda1' automatically
<method>
Start <> 00 01 //Start "BolckDeviceMon", 
//To avoid missing some POST_MOUNT message, call this method only after "device select UI" has been created and can process messages.
        I [] 
Stop <> 01 01 
        flag I [] <N> //reserved
        I [] 
GetMountPoint <> 01 01 //return mount point of file if this file has been mounted
//otherwise return ""
        file_fullname S [] <> 
        S [] //return mount point of file if this file has been mounted
//otherwise return ""
UnMountAll <B> 01 01 
        flag I [] <> 
        I [] 
UnMount <B> 02 01 //This method can be called if user want to format some device. All partition device will be unmounted if it has partition.
//How to format device:
//Blocking call BlockDevMonitor->Unmount(dev_name);
//BlockDevMonitor->Stop()
//BlockDevFormat->Format(dev_name);
//BlockDevMonitor->Start();
        dev_name S [] <> 
        flag I [] <> //reserved
        I [] 
GetDiskInfo <> 02 01 //only valid for FAT filesytem.
//The return disk info is put into props of "DiskFreeSpace", "DiskSectorNum", "DiskSectorSize"
//parameters:
//disk_name:  path name of some directory in disk; or disk type str , such like "NAND", etc
//flag: reserved
        disk_name S [] <> 
        flag I [] <N> //reserved
        I [] 
SetLabel <> 02 01 //only valid for FAT filesytem
//disk_name:  path name of some directory in disk; or disk type str , such like "NAND", etc
        disk_name S [] <> 
        new_label S [] <> 
        I [] 
<event>
AFMSG_DEVST_POST_MOUNT <> 
AFMSG_DEVST_PRE_UNMOUNT <> 
AFMSG_DEVST_MOUNT_FAIL <> 
AFMSG_DEVST_PC_CONNECT <> 
AFMSG_DEVST_PC_DISCONNECT <> 
AFMSG_DEVST_DEVICE_NOT_RECONGNISED <> 
AFMSG_DEVST_MAX_HUB_TIERS <> 



<<Control>> Calculator [] 00000004 
<prop>
RetVal <> I [] 
<method>
Add <> 02 01 //RetVal = a + b
        a I [] 
        b I [] 
        I [] 
Sub <> 02 01 //RetVal = a - b
        a I [] 
        b I [] 
        I [] 
GetBits <> 03 01 //RetVal = (value>>position) & ((1<<bits) -1)
        value I [] 
        position I [] 
        bits I [] 
        I [] 
SetBits <> 03 01 
        position I [] 
        bits I [] 
        value I [] //RetVal = value & (((1<<bits)-1)<<position) | (value<<position)
        I [] 
Mul <> 02 01 //RetVal = a * b
        a I [] 
        b I [] 
        I [] 
Div <> 02 01 //RetVal = a / b
        a I [] 
        b I [] 
        I [] 
Mod <> 02 01 //RetVal = a % b
        a I [] 
        b I [] 
        I [] 
ShiftLeft <> 02 01 //RetVal = value << bits
        value I [] 
        bits I [] 
        I [] 
ShiftRight <> 02 01 //RetVal = value >> bits
        value I [] 
        bits I [] 
        I [] 
Random <> 01 01 //rand()%range
        range I [] 
        I [] 
<event>



<<Control>> DrawTools [] 00000019 <> 
<prop>
drawed_area <R> GR [] //returne the drawing area after some draw method is called
<method>
DrawLine <> 06 01 //Draw a line
        layer I [] <> 
        x0 I [] <> 
        y0 I [] <> 
        x1 I [] <> 
        y1 I [] <> 
        color I [] <> 
        I [] 
DrawIcon <> 03 01 //af_draw_icon( x,  y, icon_resource)
        layer I [] <> 
        rect H [Rect] <> 
        icon RI [] <> 
        I [] 
DrawIconEx <> 08 01 //put "icon" to "rect" with "mode" and "effect"
        layer I [] <> //put icon to osd layer -- 0 or 1
        x I [] <> //dest x
        y I [] <> //dest y
        icon RI [] <> //icon resource id
        mode I [] <> //0 -- not write 100% transparent pixels in icon to preserve background
//1 -- write all pixels
        effect I [] <N> //effct:
//0 -- no effect
//1 -- scale to "effect_rect"
//2 -- clip to "effect_rect"
//2 -- x_rotate, 0-360 degree in "effect_param"
//3 -- y_rotate, 0-360 degree in "effect_param"
        effect_rect I [] <N> //dest rect for "effect"
        effect_param I [] <N> //param for "effect"
        I [] 
DrawString <> 05 01 
        layer I [] <> 
        text S [] <> 
        rect H [Rect] <> 
        color I [] <> 
        size I [] <N> //only useful when current font is a true type font 
        I [] 
DrawStringM <> 05 01 
        layer I [] <> 
        text S [] <> 
        rect H [Rect] <> 
        color I [] <> 
        size I [] <N> //only useful when current font is a true type font 
        I [] 
DrawStringID <> 06 01 
        layer I [] <> 
        string_id RS [] <> 
        rect H [Rect] <> 
        color I [] <> 
        font_group_id I [] <> 
        size I [] <N> //only useful when current font is a true type font 
        I [] 
DrawStringIDM <> 06 01 
        layer I [] <> 
        string_id RS [] <> 
        rect H [Rect] <> 
        color I [] <> 
        font_group_id I [] <> 
        size I [] <N> //only useful when current font is a true type font 
        I [] 
DrawStringR <> 06 01 
        layer I [] <> 
        text S [] <> 
        rect H [Rect] <> 
        color I [] <> 
        font_group_id I [] <N> 
        size I [] <N> //only useful when current font is a true type font 
        I [] 
DrawStringIDR <> 06 01 
        layer I [] <> 
        string_id RS [] <> 
        rect H [Rect] <> 
        color I [] <> 
        font_group_id I [] <> 
        size I [] <N> //only useful when current font is a true type font 
        I [] 
DrawRect <> 04 01 
        layer I [] <> 
        rect H [Rect] <> 
        color I [] <> 
        mode I [] <> 
        I [] 
CopyVideo <> 04 01 //Copy image in window "src_wnd" on current video layer to OSD position ('dst_x", "dst_y") on osd "layer"
        src_wnd H [Rect] <> 
        layer I [] <> 
        dst_x I [] <> 
        dst_y I [] <> 
        I [] 
<event>



<<Control>> FileTreeManager [FileTreeMgr] 00000026 <S> //Provide management of path cache, attributes, media type
//There are four types of attributes 
//1. predefined attributes:
//ModifiedTime, ModifiedTime.Year, ModifiedTime.Month, ModifiedTime.Day, ModifiedTime.YearMonth
//CreatedTime, CreatedTime.Year, CreatedTime.Month, CreatedTime.Day, CreatedTime.YearMonth
//FileSize
//FileName
//PathName
//SubItemURL.0, SubItemURL.1, etc
//SubItemCount
//TypeStr  (file type string, it include below strings and the media type name which is defined in FileTreeManager: Dir,   Hide,  System , Other (all files not defined in FileTreeManager)
//If one item is both dir and hide item, the string returned is "Dir,Hide")
//2. Mark, Mark.xxx (xxx is defined in Prop of "MarkDefines)
//3. User defined attributes: they are defined in Prop of "UserAttrNames" and "UserAttrSources", one "UserAttrSources" can support multi attr names (see detail in FileNav document)
//4. ReadOnly Attributes: these attributes are returned by RdOnlyAttrSrc (see detail in FileNav document)
//* attributes of "SubItemCount", "SubItemURL.xxx" can not be used in filter or Sorter
<prop>
Config <S> I [] //Config[bit 7~0] reserved
//Config[bit 8], 0: only cache files whose media type is registered; 1: cache all files
//Config[bit 9], 1: do not cache file name; filename is cached if bit 9 is 0 (default)
MallocMargin <> I [] //If MallocMargin is not zero, free memory space will be monitored during caching and dir will not be cached after free memory space is below this level. The unit is Byte.
CachedAttrs <S> S [] //it has format of "ModifiedTime,Rating",etc, the catched attribute can be pre-defined attributes or attributes from RdOnlyAttrSrc, UserAttrSources. 
//"Mark" is always cached even it is not listed in "CachedAttrs".
//Caching of some attributes will improve the performance, but more memory space is needed also.
UserAttrNames <S> AS [;] //the name of the attributes (Read/Write) that are defined by User. 
//Each user defined attribute have one UserAttrSource, which is defined in array of "UserAttrSources".
//The format of each item in array is like:
//"Favorite,Rating", "Favorite", "Favorite:0,Rating:0" etc.
//"Favorite:0,Rating:0" means the default value of Favorite is "0" ; "" is used as default value if default value is not set.
//The default will be used (and cached) if the corresponding UserAttrSource return "" or NULL.
UserAttrSources <S> AH [;AttributeRWSrc] //the source handle of the attributes that are defined by User. It's name is defined in array of UserAttrNames
MarkDefines <S> AS [;] //1. the format is "Favorite:5",etc
//this string define Mark of "Favorite", which has the maximum state of 5  (0~4)
//2. Use attribute name of "Mark.Favorite" to access it's value
//3. The total bits used by all Marks must be less than or equal to 8
MediaDefines <SC> AS [0~8;] //the format is "Audio:mp3,wma,wav",etc. This string define media type of "Audio"; 
HeadNodDefines <S> AS [;] //User can define some special virtual file nodes at the head of each directory, such like: "__UP__", "Play All".
//User need give the ext name for each virtual file node, so that this special file node can have a media type (defined by prop of "MediaDefines") and can be filtered if user does not want to show it.
//One special virtual file node is "__UP__.xxx" (xxx is ext name),  FileBrowser will call method of "UpDirectory" automatically when this file node is clicked.
<method>
LoadUAttr2Cache <B> 03 01 //Load user attrs of all files in directory or sub-directories of base_dir into cache.
//The attrs should be defined in prop of UserAttrNames
        UserAttrNames S [] <> //it has format of "attr_name1,attr_names", etc
        base_dir S [] <> //usually it is mount_point
        flag I [] <> //flag: 
//0,1, use default value if the attr of some item does not exist in DB file (AttrsDB)
//2, get attr value from UserAttrSources again if the attr of some item does not exist in DB file (AttrsDB)
        I [] 
GetAttribute <B> 02 01 //now only "Blocking call" is supported.
//the return parameter name is: "s_ret" (STR, get by control InOutParam.GetBlkFunRetStr). 
        url S [] <> 
        attr_name S [] <> 
        S [] 
SetAttribute <B> 03 01 //now only "Blocking call" is supported.
        url S [] <> 
        attr_name S [] <> 
        attr_val S [] <> 
        S [] 
ClearMark <> 01 01 //clear all files' mark (only for mark of "mark_name")
//mark_name: the name of Mark that will be cleared.
        mark_name S [] <> 
        I [] 
ReqFillPath <> 01 01 //Request to fill path cache, sub directories are included.
        pathname S [] <> 
        I [] 
<event>
AFMSG_DEVST_PRE_UNMOUNT <I> //This type of control should process the message of "PRE_UNMOUNT" , check if any directory in it's path cache has been unmounted.
//If any directory in it's path cache is unmounted, it need refresh it's cache and broadcast message of "FILETREE_REFRESH",
//The UI control (FileBrowser) will refresh displaying. 
AFMSG_DEVST_DEV_REFRESH <I> //message of "DEV_REFRESH" should be processed , usually this message is sent out by any control that may change files in some disk (such like copy,del method in GeneralFileOp)
//If any directory files in it's path cache is changed, it need refresh it's cache and broadcast message of "FILETREE_REFRESH" . The UI control (FileBrowser) will refresh displaying 
AFMSG_DEVST_POST_MOUNT <I> 
AFMSG_FITRE_CACHING_PROGRESS <> 
AFMSG_FITRE_CACHING_DONE <> 



<<Control>> GUITouchMgr [GUITouchMgrTpl] 00000005 
<prop>
<method>
GetInterface <> 00 01 
        I [] 
<event>



<<Control>> InOutParam [] 00000009 <S> 
<prop>
RetVal <> I [] 
RetStr <> S [] 
<method>
SetPageInputVal <> 04 01 
        param_name S [] <> 
        param_val I [] <> 
        page_handle H [] <> 
        flag I [] <N> //bit[0]: 0, set this parameter as n/a after page is destroyed;   1, keep the value of this parameter after page is destroyed.
        I [] 
SetPageInputStr <> 04 01 
        param_name S [] <> 
        param_str S [] <> 
        page_handle H [] <> 
        flag I [] <N> //bit[0]: 0, set this parameter as n/a after page is destroyed;   1, keep the value of this parameter after page is destroyed.
        I [] 
GetPageInputVal <> 01 01 
        param_name S [] <> 
        I [] 
GetPageInputStr <> 01 01 
        param_name S [] <> 
        S [] 
SetPageRetVal <> 02 01 
        param_name S [] <> 
        param_val I [] <> 
        I [] 
SetPageRetStr <> 02 01 
        param_name S [] <> 
        param_str S [] <> 
        I [] 
GetBlkFunRetVal <> 01 01 
        param_name S [] <> 
        I [] 
GetBlkFunRetStr <> 01 01 
        param_name S [] <> // 
        S [] 
<event>



<<Control>> KeyInput [] 00000011 <> 
<prop>
KeyIONum <SCg> I [3~5] //How mamy IO or ADC level for key detect? 3 or 5.
//if less than 7 keys, it should be 3.
//if >7 keys & < 31 keys, it should be 5.
ShortKeyDly <SCg> I [1~100] //Short key press delay.
DoubleKeyDly <SCg> I [1~20] //Double key press delay.
Short2HoldDly <SCg> I [1~100] //Short key to Hold key delay time.
HoldKeyDly <SCg> I [1~100] //Hold key delay.
Hold2LongDly <SCg> I [1~100] //Hold key to hold long key delay.
HoldLongKeyDly <SCg> I [1~100] //Hold long key delay.
Key7 <SCg> AI [0~8;:AfKey] //Short key mapping for 7 keys.
//The item0 must be UOP_NOP.
HoldKey7 <SCg> AI [0~8;:AfKey] //Hold key mapping for 7 long keys
//The item0 must be UOP_NOP.
HoldRlsKey7 <SCg> AI [0~8;:AfKey] //Rlease hold key mapping for 7 keys.
//The item0 must be UOP_NOP.
LongKey7 <SCg> AI [0~8;:AfKey] //Hold long key mapping for 7 keys.
//The item0 must be UOP_NOP.
LongRlsKey7 <SCg> AI [0~8;:AfKey] //Release hold long key mapping for 7 keys.
//The item0 must be UOP_NOP.
DoubleKey7 <SCg> AI [0~8;:AfKey] //Double key mapping for 7 keys.
//The item0 must be UOP_NOP.
Key31 <SCg> AI [0~32;:AfKey] //Short key mapping for 31 keys
//The item0 must be UOP_NOP.
HoldKey31 <SCg> AI [0~32;:AfKey] //Hold key mapping for 31 long keys.
//The item0 must be UOP_NOP.
HoldRlsKey31 <SCg> AI [0~32;:AfKey] //Release hold key mapping for 31 keys.
//The item0 must be UOP_NOP.
LongKey31 <SCg> AI [0~32;:AfKey] //Hold long key mapping for 31 keys.
//The item0 must be UOP_NOP.
LongRlsKey31 <SCg> AI [0~32;:AfKey] //Release hold long key mapping for 31 keys.
//The item0 must be UOP_NOP.
DoubleKey31 <SCg> AI [0~32;:AfKey] //Double key mapping for 31 keys.
//The item0 must be UOP_NOP.
<method>
KeyInputDisable <> 01 01 
        disable I [0~1] <> //0: enable, 1:disable
        I [] 
<event>
AFMSG_INPUT_REMOTE_INPUT <> 
AFMSG_SYS_REGISTER <I>



<<Control>> NecRemoteInput [] 00000009 <> 
<prop>
customer_code <S> I [] 
leader_act_time <> I [] //leader active time (¦Ìs) , format as : 0xaaaabbbb,  aaaa---max time, bbbb---min time
leader_idl_time <> I [] //leader idle time (¦Ìs) , format as : 0xaaaabbbb,  aaaa---max time, bbbb---min time
rep_idl_time <> I [] //repeat leader active time (¦Ìs) , format as : 0xaaaabbbb,  aaaa---max time, bbbb---min time
bit0_ident_time <> I [] //bit 0 identification time (¦Ìs) , format as : 0xaaaabbbb,  aaaa---max time, bbbb---min time
ir_polarity <> I [0~1] //Polarity of the input signal, defaut is 0, you can set as 1 to change the polarity
IRQ_selection <> I [0~3] //IRQ Selection and width measurement reset:
//00:	IR Decoder done [default]
//01:	IR input rising or falling edge detected
//10:	IR input falling edge detected
//11:	IR rising edge detected
frame_mask <> I [0~3] //Frame mask.  These bits are used to qualify frames for capture.
//11:	Capture all frames good or bad
//01:	Capture only frames where data=~data.  Ignore custom codes
//10:	Capture only frames where custom_code = ~custom_code.  Ignore data codes
//00:	Capture only frames where (data=~data) and (custom_code = ~custom_code) (default)
hold_first_key <> I [0~1] //Hold Last Key.  If this parameter is set as 0, then the frame data register will only be updated if hasn't already been updated.  Once updated, the frame data register will not be updated again until it has been read.  This bit can be used to guarantee the first TV remote code captured will not be overwritten by subsequent transmissions from a TV remote.
//NOTE:  You must read the frame data register to clear an internal hold last flag if this parameter set as 0.
//default: 0
decode_mode <> I [0~3] //Decoder mode
//00:	NEC Frames: Decode Leader and 32 bits [default]
//01:	Only accumulate bits (skip the leader)
//10:	Measure Mode.
//11:	NEC Frames: Decode Leader and 32 bits
bit_number <> I [0~31] //Number of bits in the IR frame (N-1), default [0x1f]
rawcodesavemode <> I [0~1] //0  ---  save row code[0~0xff] with ordinal in a map [default]
//1  ---  save row code in a map without ordinal, slowly in read process
//You must set it if the remote row data code has more than 8 bits
raw_code <S> AI [;] 
afkey_val <S> AI [;:AfKey] 
afkey_flag <> AI [;] 
afkey_str <S> AS [;] 
<method>
<event>
AFMSG_INPUT_REMOTE_INPUT <> 
AFMSG_SYS_REGISTER <I> 



<<Control>> PicPlayer [BasicPlayer,AttributeSource] 00000043 <> 
<prop>
SlideDuration <> I [] //Slide duration,
DisplayOption <> I [] //Picture display option:PIC_SHOW_SMART_CROP (1),PIC_SHOW_FULL_IMAGE (0),PIC_SHOW_CINEMA_MODE (5),PIC_SHOW_FULL_SCREEN_KEEP_RATIO (3);  
BGroundColor <> I [] 
ErrProcessCfg <> I [] //Error Process Config, bit[0]: use  default jpeg instead of error picture when error happen
Config <> I [] //Config, bit[0~3] zoom mode, 0 normal zoom . config[4] is for photo style mode. 0 means no photo style.
SlideTransLeft <> I [] 
SlideTransRight <> I [] 
TranMode <> I [] //Slide show transition mode
TranCfg0 <> I [] //Slide show random transition config
TranCfg1 <> I [] //Slide show random transition config
TranCfg2 <> I [] //Slide show random transition config
TranCfg3 <> I [] //Slide show random transition config 
FrameDirection <> I [] 
RotateInput <> I [] 
BkEnable <> I [] 
BkClear <> I [] 
MovieIconEnable <> I [] 
RotateLevel <> I [] 
ExtraInfo <> H [PicUtil] 
FastPlayTime <H> I [] //unit: 0.1s; 0: fast forward/backward without playing sound
SendMsgFun <H> I [] //Readonly,   Container send msg function. This is internal interface set by container and casted to type of function pointer. Player call it to send it's message 
SendMsgArg <H> I [] //Readonly,  Container send msg arg.
//This is internal interface set by container and casted to type of "void*",  BasicPlayer assign it message pointer before calling SendMsgFun.
AppType <C> S [] //The  supported files's extention name, has the format like:
//"mp3,mov,mp4"  
ThumbnailCfg <> I [] //thumbnail config, input: 1 thumbnail prefered, 
MagicWinMode <> I [] 
MagicWinEnable <> I [] 
InputMagicIndex <> I [] 
DefaulPic <> RT [] //play default picture when unsupport picture.
InputMagicWin <Cg> ART [;] 
<method>
GetAttribute <H> 02 01 
        url S [] <> //url of item
        attr_name S [] <> //The name of attribute
        S [] //attr value
Rotate <> 01 01 
        direction I [] <> 
        I [] //0: clockwise ,90 degree
//1: antilclockwise  ,90 degree.
//2: 180 degree.
SetInterval <> 01 01 //Set slide show interval
        interval I [] <> //0:1s 1:3s 2:5s 3:10s 4:forever 5:15s 6:30s 7:1m 8:5m 9:10m 10:15m 11:1h 12:1day 13:0s 
        I [] 
SetPicEnhance <> 01 01 
        flag I [:PicEnhance] <> 
        I [] 
SetPicPolicy <> 02 01 
        type I [:PIC_EFFECT] <> 
        flag I [] <> 
        I [] 
SetTransMode <> 00 01 
        I [] 
StartMagicWin <> 01 01 //enable  sub window slideshow with transition effect
        para I [] <> 
        I [] 
StopMagicWin <> 01 01 
        para I [] <> 
        I [] 
StopTransition <> 01 01 //stop current transition immediately
        flag I [] <> 
        I [] 
SetFrameDir <> 01 01 
        frame_direction I [] <> //Set Frame Direction
        I [] 
SetDispOption <> 01 01 
        dispoption I [] <> 
        I [] 
Start <H> 00 01 //Create app task      
        I [] 
Quit <H> 00 01 //Delete app task        
        I [] 
Play <H> 05 01 //Play the file (url is not NULL and state is "STOP")
//Or change state from "PAUSE", "FF", "FB" to normal playing ( url is NULL)
        url S [] <> //if url is not NULL and player is in "STOP" state, play a new item (player must be in "STOP" state)
//if url is NULL and player is in "PAUSE", "FF", "FB", change state to normal playing (player  can not be in "STOP" state)
        window_x I [] <> // 
        window_y I [] <> 
        window_width I [] <> 
        window_height I [] <> // 
        I [:StreamType] //fail, return -1
//not support, return -2
//success:
//return StreamType: 
//STREAMTYPE_AUDIOONLY,
//STREAMTYPE_PICTURE,
//STREAMTYPE_VIDEO
Stop <H> 00 01 //Stop playing
        I [] 
Pause <H> 00 01 //Pause     
        I [] 
FastForward <H> 01 01 //Fast forward
        level I [] <> 
        I [] //return -1 if not support
FastBackward <H> 01 01 //Fast backward
        level I [] <> 
        I [] //return -1 if not support
ReqPageUP <> 00 01 //use special page up transition effect
        I [] 
ReqPageDOWN <> 00 01 //use special page down transition effect
        I [] 
TimeSearch <H> 02 01 // 
        time I [] <> //start play time; 
        pause_flag I [] <> //flag: 0 normal play after time search, 1 pause after time search
        I [] //return -1 if not support
Zoom <H> 01 01 //Zoom, input: zoom level: 0, return normal display
        level I [] <> 
        I [] 
Pan <H> 02 01 //  
        direction I [] <> 
        distance I [] <> 
        I [] 
SetParam <H> 02 01 //set parameters for below method, it will be reset after any of below method are called:
//1. method of Play:
//"time", the start playing time
        param_name S [] <> 
        value I [] <> 
        I [] 
<event>
AFMSG_PIC_PROCESS_FINISH <>



<<Control>> Rect [Rect] 00000001 <> 
<prop>
XYWH <g> GR [] //The position and size of control
<method>
<event> 



<<Control>> StringTable [StringTableWR,StringTableRD,StringTable,StringTableEx] 00000023 <> 
<prop>
Sorter <H> H [SorterT] 
InitRow <> AS [;] //the initial row in this table, it has format like: "row_name,col0_string,col1_string", etc
RowProfContent <> AS [;] //The Configuration for the row that is needed to be saved or loaded with "profile"
//Each configuration item has format of: "row_name:ALL", "row_name:STR", or "row_name:SELCOL".
//"row_name:STR" will save the string of each col , "row_name:SELCOL" will save the selected col index of this row. "row_name:ALL" will save both of these two information.
//If this prop is not set, all rows will be loaded or saved when calling LoadProfile and SaveProfile.
ColNickNameList <SD> AS [;] //Nickname of "__ROWNAME__", "__INFO__" are reserved for row_name and info_data of each row.
//"0","1","15",etc are used if Nickname of some col is not set.
<method>
Query <> 03 01 //return the string in colmun "return_col", if the string in same row and in column "col" has "match_string"
        col I [] <> 
        result_col I [] <> 
        match_string S [] <> 
        S [] 
QueryEx <> 03 01 
        col_name S [] <> 
        result_col_name S [] <> 
        match_string S [] <> 
        S [] 
SetValue <> 03 01 
        row_name S [] <> 
        col_index I [] <> 
        value I [] <> 
        I [] 
GetValue <> 02 01 
        row_name S [] <> 
        col_index I [] <> 
        I [] 
GetValueEx <> 02 01 
        row_name S [] <> 
        col_name S [] <> 
        I [] 
GetStringEx <> 02 01 
        row_name S [] <> 
        col_name S [] <> 
        S [] 
Query2StrTable <> 02 01 //Query the rows that meet the condition in "cond_string"
//The result is put into prop of "QueryResultTab" (another StringTable)
        cond_string S [] <> // it has format of:
//"col_nickname1==ABC",
//"col_nickname1==ABC&colnickname2!=DEF", 
//"col_nickname1==ABC|colnickname2==DEF",
//"col_nickname1==ABC|colnickname2==DEF&colnickname3!=GHI"
//etc
//* col_nickname is  defined by user (prop of "ColNickNameList") or have the default name (set by owner control)
//* Order of Precedence: & (AND) is higher than | (OR)
        result_str_tab H [StringTableWR] <> 
        S [] 
GetColIndex <> 01 01 //The the col index by it's nickname {0~ColCount-1}
//Return -1 if ColNickName does not exist.
        ColNickName S [] <> 
        I [] 
GetRowCount <> 00 01 
        I [] 
GetColCount <> 01 01 
        row_name S [] <> 
        I [] 
GetString <> 02 01 
        row_name S [] <> 
        col_index I [] <> 
        S [] 
GetRowName <> 01 01 
        row_index I [] <> 
        S [] 
GetRowIndex <> 01 01 
        row_name S [] <> 
        I [] 
LoadProfile <> 01 01 
        profile_src H [Profile] <> 
        I [] 
SaveProfile <> 02 01 //save profile of all rows that are set in "RowProfContent" if row_name is zero length string.
        profile_src H [Profile] <> //save profile of all rows that are set in "RowProfContent" if row_name is zero length string.
        row_name S [] <> //save profile of all rows that are set in "RowProfContent" if row_name is zero length string.
        I [] 
SetSorter <> 01 01 
        Sorter H [SorterT] <N> 
        I [] 
AddRow <> 01 01 
        row_name S [] <> 
        I [] 
DelRow <> 01 01 
        row_name S [] <> 
        I [] 
SetString <> 03 01 
        row_name S [] <> 
        col_index I [] <> 
        string S [] <> 
        I [] 
DelString <> 02 01 
        row_name S [] <> 
        col_index I [] <> 
        I [] 
Release <> 00 01 
        I [] 
GetRowInfo <> 01 01 
        row_name S [] <> 
        I [] 
SetRowInfo <> 02 01 
        row_name S [] <> 
        info_data I [] <> 
        I [] 
GetSelColIndex <> 01 01 
        row_name S [] <> 
        I [] 
SetSelColIndex <> 02 01 
        row_name S [] <> 
        col_index I [] <> 
        I [] 
GetRowNameStrID <H> 01 01 
        row_name S [] <> 
        I [] 
SetRowNameStrID <> 02 01 
        row_name S [] <> 
        strID RS [] <> 
        I [] 
<event>
AFMSG_STRTB_REFRESH <> 



<<Control>> StrManipulator [] 00000008 <> 
<prop>
RetVal <> I [] 
RetStr <> S [] 
<method>
IsSubStr <> 02 01 //RetVal = (int)strstr(str2, str1)
        substr S [] <> 
        str S [] <> 
        I [] 
SubStr <> 03 01 //RetStr = substring of str from position to position+length-1
        str S [] <> 
        position I [] <> 
        length I [] <> 
        S [] 
StrCat <> 02 01 //RetStr = strcat(str1, str2);
        str1 S [] <> 
        str2 S [] <> 
        S [] 
StrToInt <> 01 01 //RetVal = atoi(str)
        str S [] <> 
        I [] 
IntToStr <> 01 01 //RetStr = itoa(value)
        value I [] <> 
        S [] 
HexStrToInt <> 01 01 //RetVal = htoi(str)
        str S [] <> 
        I [] 
FilenameCmp <> 02 01 //Compare filename with each pathname in PathSet, return compare result if filename is equal or in one of these path.
//The pathname is put in prop of RetStr.
//return value:
//0, not match
//1, filename==path 
//2, filename is in directory of path 
//3, filename is in directory or subdirectory of path 
        filename S [] <> 
        PathSet S [] <> //the name of one path or multi path (have format of "path1,path2,path3", etc )
        I [] //return value:
//0, not match
//1, filename==path 
//2, filename is in directory of path 
//3, filename is in directory or subdirectory of path 
ExtractFileName <> 01 01 //extract the filename from full path name of file, the filename is put prop of RetStr also
        fullname S [] <> 
        S [] //filename
ExtractPath <> 01 01 //extract the path from full path file name, result is assigned to property RetStr.
        fullname S [] <> 
        S [] //path
ExtractFileExt <> 01 01 
        fullname S [] <> 
        S [] 
<event> 



<<Control>> Upgrade [] 00000013 <> 
<prop>
SystemHandle <> H [Bsp] 
FileName <R> S [] 
UpgradeHandle <> H [UpgradeHandle] 
Info <D> AS [;] 
Customer <RD> AI [;] 
Version <RD> AI [;] 
CreateDate <RD> AI [;] 
Platform <D> AI [;] 
Slot <RD> AI [;] 
<method>
GetInfo <> 01 01 
        num I [] <> 
        S [] 
GetPlatform <> 01 01 
        num I [] <> 
        I [] 
GetVersion <> 01 01 
        num I [] <> 
        I [] 
GetCreateDate <> 01 01 
        num I [] <> 
        I [] 
GetCustomer <> 01 01 
        num I [] <> 
        I [] 
Check <> 00 01 //Check whether it is a legal file
        I [] 
Start <> 00 01 //Start Upgrade process
        I [] 
SetFileName <> 01 01 //Set Upgrade File Name
        filename S [] <> //upgrade filename , full path
        I [] //Success or Fail
<event>
AFMSG_UPG_UPGRADE_CHECK_OK <> 
AFMSG_UPG_UPGRADE_CHECK_ERROR <> 
AFMSG_UPG_UPGRADE_FAIL <> 
AFMSG_UPG_UPGRADE_OPEN_ERROR <> 
AFMSG_UPG_UPGRADE_FINISHED <> 
AFMSG_UPG_UPGRADE_IN_PROGESS <> 



<<Control>> Variables [] 00000001 
<prop>
int0 <> I [] 
int1 <> I [] 
int2 <> I [] 
int3 <> I [] 
int4 <> I [] 
int5 <> I [] 
int6 <> I [] 
int7 <> I [] 
string0 <> S [] 
string1 <> S [] 
string2 <> S [] 
string3 <> S [] 
string4 <> S [] 
string5 <> S [] 
string6 <> S [] 
string7 <> S [] 
<method>
<event>

<<Control>> uADCKey [] 00000007 <> 
<prop>
DACSelect <g> I [0~1] //0 internal DAC, 1 external
enableADC <Cg> I [0~1] 
<method>
GetBatteryLevel <> 00 01 
        I [] 
Mute <> 01 01 
        val I [] <> 
        I [] 
EnableCF <> 01 01 //cf card detects
        flag I [0~] <> //0: disable
//1: enalble
        I [] 
<event>
AFMSG_UUSER_ADKEY_INPUT <> 



<<Control>> uBsp [Bsp] 00000002 <> 
<prop>
SystemDesc <R> I [] 
<method>
SystemReset <> 00 01 
        I [] 
<event>



<<Control>> uCardDevice [] 00000009 
<prop>
<method>
<event>
AFMSG_SYS_REGISTER <I> 



<<Control>> uColorMode [] 00000006 <S> //#ifdefine TTF 
//	//osd1 using a group of 5 indexs
//	#define OSD1_Yellow    0x1
//	#define OSD1_White     0x2
//	#define OSD1_Black     0x3
//	#define OSD1_Gray      0x4
//	#define OSD1_Green     0x5
//	//osd2 using RGBA 
//	#define OSD2_White     0xffffffff
//	#define OSD2_Yellow    0xffb700ff
//	#define OSD2_Gray      0x7d7d7dff
//	#define OSD2_Green     0x66ff00ff
//	#define OSD2_Black     0x000000ff
//#else
//	//osd1 using a index
//	#define OSD1_Yellow    5//0x05
//	#define OSD1_White     10//0x0A
//	#define OSD1_Black     15//0x0f
//	#define OSD1_Gray      20//0x14
//	#define OSD1_Green     25//0x5
//	//osd2 using ABGR
//	#define OSD2_White     0xffffffff
//	#define OSD2_Yellow    0xff00b7ff
//	#define OSD2_Gray      0xff7d7d7d
//	#define OSD2_Green     0xff00ff66
//	#define OSD2_Black     0xff000000
//#endif
<prop>
colorType <C> I [0~1] 
yellow <> I [] 
white <> I [] 
black <> I [] 
gray <> I [] 
green <> I [] 
osd1Yellow <> I [] 
osd1White <> I [] 
osd1Black <> I [] 
osd1Gray <> I [] 
osd1Green <> I [] 
osd2Yellow <> I [] 
osd2White <> I [] 
osd2Black <> I [] 
osd2Gray <> I [] 
osd2Green <> I [] 
osd2WhiteBlack <> I [] 
osd2WhiteYellow <> I [] 
osd2BlackYellow <> I [] 
osd2GrayYellow <> I [] 
osd2GrayBlack <> I [] 
<method>
SetLayer <> 01 01 
        rect H [Rect] <> 
        I [] 
<event>



<<Control>> uColorPreSet [] 00000004 <> 
<prop>
FontColorNum <> I [] //the  using color nums
OsdLayer <> I [] //0----->OsdLayer0
//1------->OsdLayer1
FontColors <D> AI [;] //example:
//color1: frontground color . background color,
<method>
<event>



<<Control>> uDisplayDevice [] 00000002 <> 
<prop>
<method>
DisableOSDLayer <> 02 01 //Disable OSD layer 0 or layer 1.
        layer I [0~1] <> //0: layer0, 1: layer1.
        flag I [0~1] <> //0: enable; 1: disable.
        I [] 
<event>
AFMSG_SYS_REGISTER <I> 



<<Control>> uFunctionSet [] 00000037 <> 
<prop>
<method>
DrawText <> 06 01 
        layer I [] <> 
        text S [] <> 
        rect H [Rect] <> 
        color I [] <> 
        font_size I [] <> 
        line_space I [] <> 
        I [] 
DrawTextID <> 06 01 
        layer I [] <> 
        string_id RS [] <> 
        rect H [Rect] <> 
        color I [] <> 
        font_size I [] <> 
        line_space I [] <> 
        I [] 
Delay <> 01 01 
        time I [] <> //unit is 100ms.
        I [] 
<event>



<<Control>> uIconButton [ButtonGroupItem] 00000014 <> 
<prop>
XYWH <C> GR [] //Position and Size of Button Item
state <> I [:ButtonState] //The State of Button
label <> S [] //Text
option <> I [] 
unfocus_bg_icon <C> RI [] //1: not clear rect when Hide
unfocus_fg_icon <> GI [] 
unfocus_label <> GS [] 
focus_bg_icon <C> RI [] 
focus_fg_icon <> GI [] 
focus_label <> GS [] 
disable_bg_icon <> RI [] 
disable_fg_icon <> GI [] 
disable_label <> GS [] 
press_bg_icon <> RI [] 
press_fg_icon <> GI [] 
press_label <> GS [] 
drawrectnum <> I [] //draw rect arear nums
multilineflag <> I [] //0: one line 1:multi-line
line_length <> I [] //char number
y_distance <> I [] //the distance
drawrect <> AI [0~10;] //0:osd layer  1:x0  2:y0  3:w  4:h  5:distance  6:clear color  7:draw color  8:draw mode 
<method>
Draw <> 00 01 //Draw
        I [] 
Hide <> 00 01 //Hide
        I [] 
DrawRect <> 01 01 //draw rect 
        item I [] //draw rect numbers
        I [] 
ChangeIcon <> 03 01 
        unfocus_bg_icon RI [] 
        focus_bg_icon RI [] 
        disable_bg_icon RI [] 
        I [] 
<event>



<<Control>> uNandDevice [] 00000000 
<prop>
<method>
<event>
AFMSG_SYS_REGISTER <I> 



<<Control>> uPanelControl [] 00000003 <> 
<prop>
<method>
SetLCDBackLight <> 01 01 
        level I [0~16] <> //level:0~16;0 the most brightness,16 the most darkness
        I [] 
turnbacklight <> 01 01 
        level I [] <> //on:1;off:0
        I [] 
<event>



<<Control>> uPresetsCheck [] 00000013 <> 
<prop>
SrcDevice <> I [0~1] //the preset file source device[0:SD][1:USB]
DestPath <> S [] //for Sony P-Clock the Path is [/t_res]
ImportFileName <D> AS [;] 
UpgradeFullPath <D> AS [;] 
<method>
GetCheckResult <> 02 01 //This function is only for preinstall files,not for upgrade!!
        device_id I [0~2] <> //[0:SD][1:USB][2:NAND]
        file_index I [] <> //The index in ImportFileName array.[0.1.2....]
        I [] //1 all the file in ImportFileName array are exist.0 none exits.
UpgradeExist <> 00 01 //Check all the path in UpgradeFullPath array.Return the path that the upgrade.img in.
        S [] // one of the path that valide,none valide return "__NULL_"
CheckResImgFile <> 01 01 
        filename S [] <> 
        I [] //0 resoure.img invalide;1 ok
Parse2Nand <> 01 01 
        filename S [] <> 
        I [] 
GetVersionMsg <> 02 01 //for multi language,I have  to replace the 'xxx' to the 'curversion'.
        stringid RS [] <> 
        curversion I [] <> 
        S [] 
StartProcBar <> 01 01 
        flag I [] <> //0 upgrade;1 parse resource.
        I [] 
StopProcBar <> 01 01 
        flag I [] <> //flag  0 success; -1 error.
        I [] 
<event>



<<Control>> uProfile [Profile] 00000015 <> 
<prop>
config_filename <> S [] 
group_name <> S [] 
ret_str <> S [] 
<method>
GetProfileStr <> 01 01 
        item_name S [] <> 
        S [] 
GetProfileInt <> 01 01 
        item_name S [] <> 
        I [] 
SetProfileStr <> 02 01 
        item_name S [] <> 
        str_value S [] <> 
        I [] 
SetProfileInt <> 02 01 
        item_name S [] <> 
        int_value I [] <> 
        I [] 
SetDefault <> 00 01 
        I [] 
<event>



<<Control>> uRadioSetting [] 00000011 <> 
<prop>
lastFm <> I [] 
lastAm <> I [] 
<method>
SaveFreq <> 02 01 
        curFreq I [] <> 
        band_flag I [] <> //0 FM ;1 AM
        I [] 
DeleteFreq <> 02 01 
        curFreq I [] <> //current frequency number
        band_flag I [] <> 
        I [] 
ReadFreq <> 03 01 
        curNum I [] <> 
        mode I [] <> //0  inc
//1 dec
        band_flag I [] <> 
        I [] 
ReadNum <> 03 01 
        band_flag I [] <> 
        curFreq I [] <> 
        Flag I [] <> 
        I [] 
SaveJudge <> 02 01 
        curFreq I [] <> //curFren is current frenquency,and frenNo is the number of current frenquency.
        band_flag I [] <> 
        I [] 
GetAmNum <> 00 01 
        I [] 
GetFmNum <> 00 01 
        I [] 
GetLastFmFreq <> 00 01 
        I [] 
GetLastAmFreq <> 00 01 
        I [] 
GetString <> 03 01 
        curNum I [] <> 
        band_flag I [] <> 
        step I [] <> 
        S [] 
ResetFreq <> 00 01 
        I [] 
FreqtoNum <> 02 01 
        band_flag I [] <> 
        freq I [] <> 
        I [] 
GetPreset <> 00 01 
        I [] 
SetPreset <> 00 01 
        I [] 
<event>



<<Control>> uTSTap [TSTpl] 00000004 
<prop>
maptable <> RT [] 
priority <> I [:TSPriority] 
tap_mode <> I [:uTapMode] 
tsMgr <> H [GUITouchMgrTpl] 
indicateCtl <> H [IndicaterTpl] 
<method>
enable <> 01 01 
        enable I [] 
        I [] 
<event>
AFMSG_UUSER_TAPMSG <> 



<<Control>> uUpgradeHandle [UpgradeHandle] 00000001 <> 
<prop>
<method>
Check <> 02 01 
        Platform I [] 
        Customer I [] 
        I [] 
<event>
AFMSG_UPG_UPGRADE_CHECK_OK <I> 
AFMSG_UPG_UPGRADE_CHECK_ERROR <I> 
AFMSG_UPG_UPGRADE_FAIL <I> 
AFMSG_UPG_UPGRADE_FINISHED <I> 
AFMSG_UPG_UPGRADE_IN_PROGESS <I> 
AFMSG_UPG_UPGRADE_OPEN_ERROR <I> 



<<Control>> uUsbDevice [] 00000001 <> 
<prop>
<method>
StartUsbGadget <> 00 01 
        I [] 
<event>
AFMSG_SYS_REGISTER <I> 



<<Control>> uVideoAdjust [] 00000029 <> 
<prop>
Brightness <> I [] 
Contrast <> I [] 
Saturation <> I [] 
Hue <> I [] 
<method>
AddVideoPara <> 01 01 //++ video para   
        item I [] <> //0: brightness 1: contrast 2: color
        I [] 
MiniVideoPara <> 01 01 //-- video para
        item I [] <> //0: brightness 1: contrast 2: color
        I [] 
GetVideoPara <> 01 01 //getvideopara
        item I [] <> //0:return brightness 1:return contrast 2:retrun color
        I [] 
SetVideoPara <> 04 01 //setVideoPara
        brightness I [] <> //Brightness
        contrast I [] <> //contrast
        saturation I [] <> //Saturation
        hue I [] <> //color
        I [] 
SetVideoParaII <> 02 01 
        item I [] <> //0: brightness 1: contrast 2: color
        val I [] <> 
        I [] 
<event>




<<MsgType>>
AFMSG_BPLAY_STATE_CHANGE        15287200
AFMSG_BPLAY_PLAY_TIME        15287201
AFMSG_BPLAY_ITEM_CHANGING        15287202
AFMSG_BPLAY_ITEM_CHANGED        15287203
AFMSG_BPLAY_ITEM_NOT_SUPPORT        15287204
AFMSG_BPLAY_PLAY_FAIL        15287205
AFMSG_BPLAY_ALL_ITEM_PLAYED        15287206
AFMSG_BPLAY_PLAYLIST_EMPTY        15287207
AFMSG_BPLAY_PIC_DISPLAY        15287208
AFMSG_BPLAY_EVENT        15287209
AFMSG_BPLAY_SHOW_SUBTITLE        1528720a
AFMSG_BPLAY_AUDIO_STREAM        1528720b
AFMSG_BPLAY_SUBTITLE_STREAM        1528720c
AFMSG_BPLAY_CMD_FAIL        1528720d
AFMSG_BPLAY_MANUAL_NEXT        1528720e
AFMSG_BPLAY_MANUAL_PREV        1528720f
AFMSG_BT_OPP_CONNECT        00004a00
AFMSG_BT_OPP_DISCONNECT        00004a01
AFMSG_BT_BIP_CONNECT        00004a02
AFMSG_BT_BIP_DISCONNECT        00004a03
AFMSG_BT_FTP_CONNECT        00004a04
AFMSG_BT_FTP_DISCONNECT        00004a05
AFMSG_BT_DEV_ABORT        00004a06
AFMSG_BT_DEV_DOWN        00004a07
AFMSG_BT_PIN_CODE_REQ        00004a08
AFMSG_BT_HID_CONNECT        00004a09
AFMSG_BT_HID_DISCONNECT        00004a0a
AFMSG_BT_HID_DATA        00004a0b
AFMSG_DEVST_PRE_UNMOUNT        2230ee00
AFMSG_DEVST_POST_UNMOUNT        2230ee01
AFMSG_DEVST_POST_MOUNT        2230ee02
AFMSG_DEVST_MOUNT_FAIL        2230ee03
AFMSG_DEVST_PC_CONNECT        2230ee04
AFMSG_DEVST_PC_DISCONNECT        2230ee05
AFMSG_DEVST_PRINTER_CONNECT        2230ee06
AFMSG_DEVST_PRINTER_DISCONNECT        2230ee07
AFMSG_DEVST_DEV_REFRESH        2230ee08
AFMSG_DEVST_CARD_PLUG_IN        2230ee09
AFMSG_DEVST_CARD_PLUG_OUT        2230ee0a
AFMSG_DEVST_DEVICE_NOT_RECONGNISED        2230ee0b
AFMSG_DEVST_MAX_HUB_TIERS        2230ee0c
AFMSG_DVD_CHAPTER_CHANGED        000dba00
AFMSG_DVD_AUDIO_CHANGED        000dba01
AFMSG_DVD_SPU_CHANGED        000dba02
AFMSG_DVD_ANGLE_CHANGED        000dba03
AFMSG_DVD_ZOOM_CHANGED        000dba04
AFMSG_DVD_STATUS_CHANGED        000dba05
AFMSG_DVD_TIME_INFO        000dba06
AFMSG_DVD_FORBIDDEN        000dba07
AFMSG_DVD_PLAY_FAIL        000dba08
AFMSG_FIBRW_STATE_CHANGE        33635000
AFMSG_FIBRW_ITEM_COUNT_UPDATE        33635001
AFMSG_FIOP_REQ_COMPLETE        01e89800
AFMSG_FIOP_REQ_CANCELED        01e89801
AFMSG_FIOP_START        01e89802
AFMSG_FIOP_PROGRESS        01e89803
AFMSG_FIOP_SUCCESS        01e89804
AFMSG_FIOP_FAIL        01e89805
AFMSG_FITRE_REQUEST_READY        33968000
AFMSG_FITRE_REQ_GET_ITEM_NUM_READY        33968001
AFMSG_FITRE_REFRESH        33968002
AFMSG_FITRE_ADD_ENTRY_RESULT        33968003
AFMSG_FITRE_CACHING_PROGRESS        33968004
AFMSG_FITRE_CACHING_DONE        33968005
AFMSG_GENMG_INDICATION        3a6d4a00
AFMSG_GPLAY_UPDATE_SPECTRUM        3db42700
AFMSG_GPLAY_UPDATE_LYRIC        3db42701
AFMSG_GUI_ITEM_FOCUS_CHANGE        00162f00
AFMSG_GUI_ITEM_FOCUS_SELECTED        00162f01
AFMSG_GUI_ITEM_DRAW_FINISHED        00162f02
AFMSG_GUI_ITEM_SLIDE_FINISHED        00162f03
AFMSG_INPUT_REMOTE_INPUT        4d5fbe00
AFMSG_NET_YAHOO_RESULT_REFRESH        00287900
AFMSG_NET_POPMAIL_CLIENT_EVENT        00287901
AFMSG_NET_POPMAIL_NEW_MAIL        00287902
AFMSG_NET_SNTP_SYNC        00287903
AFMSG_NETST_DEV_OFF        7342a600
AFMSG_NETST_DEV_ON        7342a601
AFMSG_NETST_DEV_PLUG        7342a602
AFMSG_NETST_DEV_UNPLUG        7342a603
AFMSG_NETST_NETIF_OFF        7342a604
AFMSG_NETST_NETIF_ON        7342a605
AFMSG_NETST_NETIF_READY        7342a606
AFMSG_NETST_WIFI_SCAN_READY        7342a607
AFMSG_NETST_WIFI_SCAN_REFRESH        7342a608
AFMSG_NETST_WIFI_CONNECT_TIMEOUT        7342a609
AFMSG_NETST_WIFI_CONNECT_CANCEL        7342a60a
AFMSG_NETST_WIFI_WPS_RESULT        7342a60b
AFMSG_NETST_WIFI_WPS_CONNECT_RESULT        7342a60c
AFMSG_PHOWB_LOGIN_SUCCESS        84534e00
AFMSG_PHOWB_LOGIN_FAIL        84534e01
AFMSG_PIC_PROCESS_FINISH        002e8600
AFMSG_PRINT_PM_FINISHED        87423500
AFMSG_PRINT_PM_CONNECT        87423501
AFMSG_PRINT_PM_DISCONNECT        87423502
AFMSG_PRINT_PM_WAITING        87423503
AFMSG_PRINT_PM_PROGRESS        87423504
AFMSG_PRINT_PM_PRITING        87423505
AFMSG_PRINT_PM_WARNING        87423506
AFMSG_PRINT_PM_ERROR        87423507
AFMSG_PRINT_PM_FILEERROR        87423508
AFMSG_STRTB_REFRESH        a049ff00
AFMSG_SYS_REGISTER        0038d100
AFMSG_SYS_DRAW        0038d101
AFMSG_SYS_HIDE        0038d102
AFMSG_SYS_INIT        0038d103
AFMSG_SYS_PAGE_DESTROYED        0038d104
AFMSG_SYS_TIMER        0038d105
AFMSG_SYS_LOST_FOCUS        0038d106
AFMSG_SYS_GOT_FOCUS        0038d107
AFMSG_SYS_DRIVER_REGISTER        0038d108
AFMSG_THUMB_ONE_THUM_READY        a4d31a00
AFMSG_THUMB_ALL_THUM_READY        a4d31a01
AFMSG_THUMB_THUM_IDLE        a4d31a02
AFMSG_THUMB_ONE_THUM_FAIL        a4d31a03
AFMSG_UPG_UPGRADE_FINISHED        003d8400
AFMSG_UPG_UPGRADE_CHECK_OK        003d8401
AFMSG_UPG_UPGRADE_CHECK_ERROR        003d8402
AFMSG_UPG_UPGRADE_OPEN_ERROR        003d8403
AFMSG_UPG_UPGRADE_FAIL        003d8404
AFMSG_UPG_UPGRADE_IN_PROGESS        003d8405
AFMSG_UPNP_AVTRANSPORT_PLAY        067db900
AFMSG_UPNP_AVTRANSPORT_STOP        067db901
AFMSG_UPNP_AVTRANSPORT_PAUSE        067db902
AFMSG_XFER_GOT_CALLBACK        0746f700
AFMSG_UCN_CHANGE_RANGE        003c2c00
AFMSG_UMMSS_PLAY_OVER        ae596500
AFMSG_UMMSS_NOT_PARSER_FILE        ae596501
AFMSG_UMMSS_NOT_EXIST        ae596502
AFMSG_UMMSS_NOT_SUPPORT        ae596503
AFMSG_UMMSS_BAD_FILE        ae596504
AFMSG_UPLAY_PF_LIMITATION_PLAY        af3b5500
AFMSG_UPLAY_PF_DEFAULT_PLAY        af3b5501
AFMSG_UUSER_QUIT_PLAYER        b0d01800
AFMSG_UUSER_TEST        b0d01801
AFMSG_UUSER_TAPMSG        b0d01802
AFMSG_UUSER_MUSIC_COVER        b0d01803
AFMSG_UUSER_ADKEY_INPUT        b0d01804
AFMSG_UUSER_IPOD_INFO        b0d01805
AFMSG_UUSER_656_PLAY        b0d01806